{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/05/10/%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0Lua%E7%89%88/",
            "url": "http://example.com/2022/05/10/%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0Lua%E7%89%88/",
            "title": "",
            "date_published": "2022-05-10T12:05:54.543Z",
            "content_html": "<h2 id=\"项目框架学习\"><a class=\"markdownIt-Anchor\" href=\"#项目框架学习\">#</a> 项目框架学习</h2>\n<h4 id=\"baseview基类\"><a class=\"markdownIt-Anchor\" href=\"#baseview基类\">#</a> BaseView 基类：</h4>\n<p>以文件名字加冒号调用类似于这种的 BaseView:__init () 皆为方法</p>\n<h5 id=\"初始化方法-__init\"><a class=\"markdownIt-Anchor\" href=\"#初始化方法-__init\">#</a> 初始化方法 __init</h5>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:__init</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"定义的成员变量-__definevar\"><a class=\"markdownIt-Anchor\" href=\"#定义的成员变量-__definevar\">#</a> 定义的成员变量 __defineVar</h5>\n<p>定义 view 模块需要的成员变量</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:__defineVar</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"打开界面前的预加载-addpreloadlist\"><a class=\"markdownIt-Anchor\" href=\"#打开界面前的预加载-addpreloadlist\">#</a> 打开界面前的预加载 AddPreLoadList</h5>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preLoad_list = <span class=\"literal\">false</span>,   <span class=\"comment\">-- 打开界面之前需要预加载的资源,除了本模块UI资源外的</span></span><br></pre></td></tr></table></figure>\n<p>将 ab 的名字，资源列表，以及类型插入到 preLoad_list 表中</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:AddPreLoadList</span><span class=\"params\">(abName, assetNameList, type)</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"从更节点开始搜寻子对象-getchild\"><a class=\"markdownIt-Anchor\" href=\"#从更节点开始搜寻子对象-getchild\">#</a> 从更节点开始搜寻子对象 GetChild</h5>\n<p>该接口暴露给外部调用</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cache_findChild = <span class=\"literal\">false</span>,  <span class=\"comment\">-- 缓存FindChild的接口</span></span><br></pre></td></tr></table></figure>\n<p>我理解的是从最外层加载的预设开始一层一层的往下找</p>\n<p>返回一个成员方法 self.cache_findChild (self.transform,name)</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:GetChild</span><span class=\"params\">(name)</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">self</span>.cache_findChild <span class=\"keyword\">and</span> <span class=\"built_in\">self</span>.transform <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">self</span>.cache_findChild(<span class=\"built_in\">self</span>.transform,name)</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"获取子对象身上的组件-getchildcomponent\"><a class=\"markdownIt-Anchor\" href=\"#获取子对象身上的组件-getchildcomponent\">#</a> 获取子对象身上的组件 GetChildComponent</h5>\n<p>该接口暴露给外部调用</p>\n<p>首先通过上面的 GetChild 方法来获取到子物体</p>\n<p>有一点要注意 name，com 都是字符类型</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:GetChildComponent</span><span class=\"params\">(name,com)</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">self</span>:GetChild(name):GetComponent(com)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"获取多个孩子transform-getchildtransforms\"><a class=\"markdownIt-Anchor\" href=\"#获取多个孩子transform-getchildtransforms\">#</a> 获取多个孩子 transform GetChildTransforms</h5>\n<p>获取到 utilManager 的组件方法，供外界使用接口</p>\n<p>这里其实 names 换成 namsList 更好理解一些</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--获取多个孩子transform</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:GetChildTransforms</span><span class=\"params\">(names)</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> GetChildTransforms(<span class=\"built_in\">self</span>.transform, names)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--获取多个孩子go</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:GetChildGameObjects</span><span class=\"params\">(names)</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> GetChildGameObjects(<span class=\"built_in\">self</span>.transform, names)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--获取多个孩子image</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:GetChildImages</span><span class=\"params\">(names)</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> GetChildImages(<span class=\"built_in\">self</span>.transform, names)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--获取多个孩子text</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:GetChildTexts</span><span class=\"params\">(names)</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> GetChildTexts(<span class=\"built_in\">self</span>.transform, names)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"是否真的打开界面-hasopen\"><a class=\"markdownIt-Anchor\" href=\"#是否真的打开界面-hasopen\">#</a> 是否真的打开界面 HasOpen</h5>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isPop = <span class=\"literal\">false</span>,                  <span class=\"comment\">-- 是否可见</span></span><br><span class=\"line\">is_loaded = <span class=\"literal\">false</span>,\t\t\t\t<span class=\"comment\">-- 是否已经加载完</span></span><br><span class=\"line\">wait_for_hide = <span class=\"literal\">false</span>,\t\t\t<span class=\"comment\">-- 等待加载完隐藏</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:HasOpen</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>供外部调用接口</p>\n<p>返回 bool 值判断界面是否真的打开</p>\n<h5 id=\"移除销毁状态-removedestroytimer\"><a class=\"markdownIt-Anchor\" href=\"#移除销毁状态-removedestroytimer\">#</a> 移除销毁状态 RemoveDestroyTimer</h5>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:RemoveDestroyTimer</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>调用了 TimerQuest.CancelQuest (GlobalTimerQuest, self.destroy_timer) 将移除状态保存起来</p>\n<h5 id=\"打开界面-open\"><a class=\"markdownIt-Anchor\" href=\"#打开界面-open\">#</a> 打开界面 Open</h5>\n<p>这个方法是打开界面的主要方法</p>\n<p>通过修改以下这些字段控制界面 view 的显示</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isPop = <span class=\"literal\">false</span>,    \t\t\t\t<span class=\"comment\">-- 是否可见</span></span><br><span class=\"line\">wait_for_hide = <span class=\"literal\">false</span>,\t\t\t<span class=\"comment\">-- 等待加载完隐藏</span></span><br><span class=\"line\">_use_delete_method = <span class=\"literal\">false</span>,\t\t<span class=\"comment\">-- 是否调用过delete函数</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:Open</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>移除定时器</p>\n<p>打开的模式默认为 OpenMode.OpenOnly，只打开界面</p>\n<ol>\n<li>如果是切换场景关闭 View，调用 EventSystem.Bind () 绑定界面，拿到 EventName 中对应的 EventId SceneEventType.SCENE_CHANGED 并注册关闭 View 事件，然后调用 auto_close_view 方法字段关闭界面</li>\n<li>如果是重新进入场景关闭 View，调用 EventSystem.Bind () 绑定界面，拿到 EventName 中对应的 EventId SceneEventType.SCENE_REENTER 并注册关闭 View 事件，然后调用 auto_close_view 方法字段关闭界面</li>\n<li>如果是切换场景隐藏 View，调用 EventSystem.Bind () 绑定界面，拿到 EventName 中对应的 EventId SceneEventType.OPEN_SCENE_LOAD_VIEW 并注册切换场景隐藏 View 事件，然后调用 auto_hide_view 方法字段隐藏界面，若场景切换完毕，则注册 EventName.SCENE_LOAD_VIEW_COMPLETE，调用 auto_show_view 方法字显示 View</li>\n<li>如果是打开界面，需要关闭主界面，就注册 EventName.CLOSE_ALL_VIEW 事件，然后调用 auto_close_view 方法字段关闭所有的 view</li>\n<li>新手引导注册 EventName.TRIGGER_GUIDE_TYPE 事件，并执行 onTriggerGuideHandler () 方法</li>\n</ol>\n<h5 id=\"异步加载资源-asnycloadlayout\"><a class=\"markdownIt-Anchor\" href=\"#异步加载资源-asnycloadlayout\">#</a> 异步加载资源 AsnycLoadLayout</h5>\n<p>需要先加载额外的依赖资源</p>\n<p>当一个界面时间大于 15s 都没有打开，那么就触发关闭的流程，避免卡住流程</p>\n<p>当没有预设的时候就创建一个新的空对象</p>\n<p>否则调用 LuaViewManager.LoadView 添加加载界面</p>\n<p>加载页面打开就确定</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:AsnycLoadLayout</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"异步资源加载完成之后打开界面-createmainwindow\"><a class=\"markdownIt-Anchor\" href=\"#异步资源加载完成之后打开界面-createmainwindow\">#</a> 异步资源加载完成之后打开界面 CreateMainWindow</h5>\n<p>在异步预加载资源之后，如果界面比较大，一时加载的资源比较多的时候，就要做延迟处理 LuaViewManager.AddDelayQueue 加入到延迟队列</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:CreateMainWindow</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"处理打开界面深度以及层级-afteropen\"><a class=\"markdownIt-Anchor\" href=\"#处理打开界面深度以及层级-afteropen\">#</a> 处理打开界面深度以及层级 AfterOpen</h5>\n<p>若界面需要等待隐藏时候就重新设置其深度值，并隐藏界面 UIZDepth.ResetUIZDepth (self)</p>\n<p>反之直接显示界面，在设置其层级 self:SetUIDepth (self.gameObject)</p>\n<p>大界面则需要加入到延迟显示队列中</p>\n<p>不需要打开就直接调用 self:Close () 关闭</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:AfterOpen</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"立即销毁界面-closedestroy\"><a class=\"markdownIt-Anchor\" href=\"#立即销毁界面-closedestroy\">#</a> 立即销毁界面 CloseDestroy ()</h5>\n<p>调用此方法以后会立即从内存中销毁界面</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:CloseDestroy</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"不需要立即从内存销毁界面-destroy\"><a class=\"markdownIt-Anchor\" href=\"#不需要立即从内存销毁界面-destroy\">#</a> 不需要立即从内存销毁界面 Destroy ()</h5>\n<p>调用此方法不会将界面从内存中马上清楚，会保留在内存中，解除绑定事件</p>\n<p>并将状态重置，然后干掉界面引用</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseView:Destroy</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n<p>界面打开模式，默认为 OpenOnly（只打开）,  还有一种 OpenToggle（界面没有打开就打开，打开了就关闭）模式</p>\n<p>界面关闭模式，默认为 CloseDestroy（立即销毁）， 另一种是 CloseVisible（隐藏）模式</p>\n<h4 id=\"basecontroller基类\"><a class=\"markdownIt-Anchor\" href=\"#basecontroller基类\">#</a> BaseController 基类：</h4>\n<h5 id=\"basecontroller__init\"><a class=\"markdownIt-Anchor\" href=\"#basecontroller__init\">#</a> BaseController:__init()</h5>\n<p>先绑定界面销毁事件监听回调，回调是依附于在界面 Destroy 的时候会触发 BaseView.DestroyEvent 函数，控制器监听到回调后就会调用 self:clearViewQuoted (view)，检查界面是否正确的执行 deleteMe 方法进行释放</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BaseController:__init</span><span class=\"params\">()</span></span></span><br><span class=\"line\">\t<span class=\"comment\">--销毁引用</span></span><br><span class=\"line\">\t <span class=\"keyword\">local</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onViewDestoryHandler</span><span class=\"params\">(view)</span></span></span><br><span class=\"line\">\t\t <span class=\"built_in\">self</span>:clearViewQuoted(view)</span><br><span class=\"line\">\t <span class=\"keyword\">end</span></span><br><span class=\"line\">\t<span class=\"built_in\">self</span>.clearViewQuoted_BindId = <span class=\"built_in\">self</span>:Bind(BaseView.DestroyEvent,onViewDestoryHandler)\t</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"basecontrollerenablecheckoutclearbool\"><a class=\"markdownIt-Anchor\" href=\"#basecontrollerenablecheckoutclearbool\">#</a> BaseController:EnableCheckoutClear(bool)</h5>\n<p>controller 实例的对象会在初始化时调用，会监听界面的 BaseView.CreateView 事件，然后将实例添加到 view_list 中</p>\n<p>当控制器监听到账户切换和角色切换就关闭所有的界面</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">self</span>:Bind(EventName.CHANGE_ACCOUNT, close_view)</span><br><span class=\"line\"><span class=\"built_in\">self</span>:Bind(EventName.CHANGE_ROLE, close_view)</span><br></pre></td></tr></table></figure>\n<h5 id=\"basecontrollerregisterprotocalid-func_name\"><a class=\"markdownIt-Anchor\" href=\"#basecontrollerregisterprotocalid-func_name\">#</a> BaseController:RegisterProtocal(id, func_name)</h5>\n<p>注册指定协议响应的方法，然后编写一个闭包函数，函数内部会查找 controller 实例中是否存在指定方法名的方法，有就执行，接着将该方法和实例注册到协议处理类的 register_list 中</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> register_func = <span class=\"literal\">nil</span> </span><br><span class=\"line\">register_func =  <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(data_list)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">local</span> oper_func = <span class=\"built_in\">self</span>[func_name]</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> oper_func <span class=\"keyword\">then</span></span><br><span class=\"line\">    \toper_func(<span class=\"built_in\">self</span>, data_list)</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> </span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">end</span>\t</span><br><span class=\"line\">UserMsgAdapter.RegisterMsgOperate(id, register_func)</span><br></pre></td></tr></table></figure>\n<h5 id=\"basecontrollersendfmttogamecmd-fmt_str\"><a class=\"markdownIt-Anchor\" href=\"#basecontrollersendfmttogamecmd-fmt_str\">#</a> BaseController:SendFmtToGame(cmd, fmt_str, …)</h5>\n<p>将协议内容整合成一个 vo，然后插入到 request_protocals_list 中</p>\n<h5 id=\"basecontrolleraddcustomdelaysendfmt-buffer\"><a class=\"markdownIt-Anchor\" href=\"#basecontrolleraddcustomdelaysendfmt-buffer\">#</a> BaseController.AddCustomDelaySendFmt( buffer )</h5>\n<p>请求将发送的协议放入 request_protocals_list 内</p>\n<h5 id=\"basecontrollerdelaysendfmttogamecombine\"><a class=\"markdownIt-Anchor\" href=\"#basecontrollerdelaysendfmttogamecombine\">#</a> BaseController.DelaySendFmtToGameCombine()</h5>\n<p>BaseController.DelaySendFmtToGame()</p>\n<p>将消息缓存到协议队列，然后在在发送的时候按帧触发，避免玩家在操作的时候频繁点击，发包量过大</p>\n<h5 id=\"basecontrollersendfmttogameimmecmd-fmt_str\"><a class=\"markdownIt-Anchor\" href=\"#basecontrollersendfmttogameimmecmd-fmt_str\">#</a> BaseController:SendFmtToGameImme(cmd, fmt_str, …)</h5>\n<p>发送重要的协议时可以调用此接口，然后就会立即发送协议一般是那种频率不高，但是内容比较重要，需要及时处理数据的时候</p>\n<p>了解了</p>\n<p>今日学习：</p>\n<p>看了项目的背包模块，</p>\n<p>Model 这一模块没有看</p>\n<p>View 这个模块 中是 load_callback（里面有 LoadSuccess 用来把 ui 界面的组件和回调方法注册到事件），open_callback 将数据跟新到界面 UI 中，close_callback 执行界面关闭时的回调。</p>\n<p>Controller 的话主要就是注册协议和绑定一些需要用到的事件，模块之间通过 Controller 来交互，引用很多其他模块</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--出现频率比较高的类或者方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--GlobalEventSystem:Fire()</span></span><br><span class=\"line\"><span class=\"comment\">--Util类</span></span><br><span class=\"line\"><span class=\"comment\">--GlobalEventSystem:Bind()</span></span><br><span class=\"line\"><span class=\"comment\">--UiFactory类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--Message.show() 飘字提示</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"25d视角\"><a class=\"markdownIt-Anchor\" href=\"#25d视角\">#</a> 2.5D 视角</h4>\n<p>AC = AB * sin (θ)，又因为 θ 就是相机的俯仰角，即为我们的所求，所以 3D 线段和投影线段之间的关系为：<strong>投影线段 = 3D 线段 * sin (俯仰角)</strong></p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210726141850309.png\" alt=\"image-20210726141850309\"></p>\n<p>由于相机俯仰运动时的旋转轴平行于 AB 方向，故而 AB 的长度即为正方形在 3D 世界中的真实长度。CD 长度垂直于俯仰旋转轴，根据上述公式可得<strong> CD 长度 = 3D 世界中正方形 CD 长度 * sin (俯仰角)</strong></p>\n<p><img data-src=\"C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210726142042723.png\" alt=\"image-20210726142042723\"></p>\n<p>故而<strong> 30° 俯视角是最佳倾斜角</strong>，也就是说<strong>图片宽高比为 1:2</strong></p>\n<p>为了切图方便，美术会把贴图的长宽像素值都设为整数，因为美术<strong>无法切出 0.5 个像素的图片</strong>，那么就要求 AB 和 CD 都是整数。如果俯仰角 θ 也是整数，将会让美术很方便地调整模型制作软件（如 Maya、3ds max 等）的相机角度，通过 3D 渲染，将 3D 模型烘焙成 2D 图片，以供游戏中直接使用</p>\n<p>遍历三角函数查找表，只有 sin (30°) 的分子分母都为整数，也就是说只有 30° 这个角度有可能让长宽都为整数，具体可参看<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wcm9vZndpa2kub3JnL3dpa2kvTml2ZW4lMjdzX1RoZW9yZW0=\">尼文定理</span>。</p>\n<p><strong>所以 2.5D 游戏应该称做斜 30 度视角游戏</strong></p>\n",
            "tags": []
        }
    ]
}